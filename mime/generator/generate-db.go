package main

import (
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"sort"
	"strings"

	"github.com/function61/gokit/net/http/ezhttp"
	"github.com/function61/gokit/mime"
)

//go:generate go run generate-db.go

func main() {
	if err := logic(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func logic() error {
	remoteDb := map[string]mime.Spec{}
	if _, err := ezhttp.Get(
		context.Background(),
		"https://raw.githubusercontent.com/jshttp/mime-db/master/db.json",
		ezhttp.RespondsJson(&remoteDb, false),
	); err != nil {
		return err
	}

	// sort, because range order over map is undefined, and we want the gen'd file to have
	// deterministic sort order as not to cause a diff storm on each update
	contentTypes := []string{}
	for contentType := range remoteDb {
		contentTypes = append(contentTypes, contentType)
	}
	sort.Strings(contentTypes)

	codeLines := []string{}
	code := func(line string) {
		codeLines = append(codeLines, line)
	}

	code("// Code generated by script in generate/ DO NOT EDIT.")
	code("")
	code("package mime")

	// for boolean pointers (not w/o hacks: https://stackoverflow.com/a/28818489)
	code("var trueVal = true")
	code("var falseVal = false")

	code("")

	code("// source https://github.com/jshttp/mime-db")
	code("var mimeTypes = map[string]*Spec{")

	for _, contentType := range contentTypes {
		spec := remoteDb[contentType]

		if len(spec.Extensions) == 0 {
			continue // we're only interested in content-types that have file extensions defined
		}

		code(fmt.Sprintf(`"%s": &Spec{`, contentType))

		if spec.Source != "" {
			code(fmt.Sprintf(`Source: "%s",`, spec.Source))
		}

		if spec.CharEncoding != "" {
			code(fmt.Sprintf(`CharEncoding: "%s",`, spec.CharEncoding))
		}

		if spec.Compressible != nil {
			if *spec.Compressible {
				code("Compressible: &trueVal,")
			} else {
				code("Compressible: &falseVal,")
			}
		}

		extensionsAsCode := ""

		for _, ext := range spec.Extensions {
			extensionsAsCode = extensionsAsCode + fmt.Sprintf(`"%s",`, ext)
		}

		code(fmt.Sprintf("Extensions: []string{%s},", extensionsAsCode))

		code("},")
	}

	code("}")

	generated := strings.Join(codeLines, "\n")

	return ioutil.WriteFile("../db.gen.go", []byte(generated), 0755)
}
